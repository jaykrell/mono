// Due to the guard page mechanism providing gradual commit of Windows stacks,
// stack pages must be touched in order.
//
// This mechanism is only transparent (kernel handles page faults and user never sees them),
// for the thread touching its own stack. Not for cross-thread stack references as are being
// done here.
//
// Here is a small program that demonstrates the behavior:
//
// #include <windows.h>
// #include <stdio.h>
//
// #pragma optimize ("x", on)
//
// int volatile * volatile Event1;
// int volatile Event2;
// HANDLE ThreadHandle;
//
// DWORD __stdcall thread (void* x)
// {
// 	while (!Event1)
// 		_mm_pause ();
//
// 	__try {
// 		*Event1 = 0x123;
// 	} __except (GetExceptionCode () == STATUS_GUARD_PAGE_VIOLATION) {
// 		printf ("oops\n");
// 	}
// 	Event2 = 1;
// 	return 0;
// }
//
// int unlucky;
// int print = 1;
//
// __declspec (noinline)
// __declspec (safebuffers)
// void f (void)
// {
// 	int local [5];
//
// 	while (unlucky && ((size_t)_AddressOfReturnAddress () - 8) & 0xFFF)
// 		f ();
//
// 	unlucky = 0;
// 	Event1 = local;
//
// 	while (!Event2)
// 		_mm_pause ();
//
// 	if (print) {
// 		printf ("%X\n", local [0]);
// 		print = 0;
// 	}
//
// 	if (ThreadHandle) {
// 		WaitForSingleObject (ThreadHandle, INFINITE);
// 		ThreadHandle = NULL;
// 	}
// }
//
// int main (int argc, char** argv)
// {
// 	unlucky = argc > 1;
// 	ThreadHandle = CreateThread (0, 0, thread, 0, 0, 0);
// 	f ();
// }
//
// This would seem to be a problem otherwise, not just for garbage collectors.
//
// We therefore have a few choices:
//
// 1. Historical slow code: VirtualQuery and check for guard page. Slow.
//
// MEMORY_BASIC_INFORMATION mem_info;
// SIZE_T result = VirtualQuery (info->client_info.stack_start, &mem_info, sizeof(mem_info));
// g_assert (result != 0);
// if (mem_info.Protect & PAGE_GUARD) {
// 	aligned_stack_start = ((char*) mem_info.BaseAddress) + mem_info.RegionSize;
// }
//
// VirtualQuery not historically allowed in UWP, but it is now.
//
// 2. Touch page under __try / __except and handle STATUS_GUARD_PAGE_VIOLATION.
//    Good but compiler specific.
//
// __try {
// 	*(volatile char*)aligned_stack_start;
// } __except (GetExceptionCode () == STATUS_GUARD_PAGE_VIOLATION) {
// 	MEMORY_BASIC_INFORMATION mem_info;
// 	const SIZE_T result = VirtualQuery(aligned_stack_start, &mem_info, sizeof(mem_info));
// 	g_assert (result >= sizeof (mem_info));
// 	VirtualProtect (aligned_stack_start, 1, mem_info.Protect | PAGE_GUARD, &mem_info.Protect);
// }
//
// 3. Vectored exception handler. Not terrible. Not compiler specific.
//
// 4. Check against the high watermark in the TIB. That is done.
//  TIB is the public prefix TEB. It is Windows.h, ntddk.h, etc.
//
